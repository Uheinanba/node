[refer](https://github.com/dt-fe/weekly/blob/master/03.%E7%B2%BE%E8%AF%BB%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%B9%8B%E4%BA%89.md
)

1. 引言
以前的模式是后端渲染，近年来渐渐演变成前端渲染。后来又开始流行起同构渲染，号称是未来，集成了前后端渲染的优点。
- 后端渲染指的是传统的ASP,java或者PHP渲染机制。
- 前端渲染指的是JS来渲染页面大部分内容，代表流行的SPA但页面应用
- 同构渲染指前后端公用JS，首次渲染时使用Nodejs来直出HTML。一般来说同构渲染介于前后端中的公共部分。
2. 内容概要
- 前端渲染优势:
* 局部刷新,无需每次都进行完整页面请求
* 懒加载，如在页面初始化时，只加载可视区域内的数据，滚动后动态加载其他数据
* 富交互。使用JS实现各种效果
* 节约服务器成本。JS支持CDN部署，只需静态文件部署
* 天生关注分离设计。服务端来访问数据库提供的接口，JS只关注数据获取和展示
* JS 一次学习，到处使用

- 后端渲染优势
* 服务端渲染不需要先先下载一堆JS和CSS后才能看到页面(首屏性能)
* SEO

3. 精读
- 前端渲染遇到的问题
前端渲染的主要问题：SEO，首屏性能
- 同构的优点
同构为了解决前端渲染遇到的问题产生的。
* 有助于SEO
* 共用前端代码，节省开发时间
同构并没有节省前端开发量，只是把一部分前端代码拿到服务端执行。并且为了同构还要处处兼容Node.js不同的执行环境，有额外的成本
* 首屏性能提高
由于SPA打包的JS往往比较大，会导致页面加载后花费很长时间来解析，造成白屏的问题。服务端渲染可以预先使到数据并渲染成最终HTML展示。理想情况下才能避免白屏问题。

- 同构并不是理想的美好
* 性能
把原来的几百万浏览器端的工作放在几台服务器来做。花费计算量还是巨大的
* 不容忽视的服务端和浏览器环境差异
> document 对象找不到
> DOM计算报错的问题
> 前端渲染和服务端渲染内容不一致的
* 内存溢出
前端代码由于浏览器环境刷新，内存重置有天然优势，对内存溢出风险没有充分考虑。比如在React中componentWillMount做绑定事件就会发生内存溢出。
* 异步操作
前端可以做非常复杂的请求合并和延迟处理，为了同构，这些请求都在预先拿到结果才渲染。这些请求很多依赖条件，难以调和。



