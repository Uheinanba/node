### node特点
1. 异步IO
2. 事件和回调函数
3. 单线程
弱点:
- 无法利用多核CPU
- 错误会引起整个应用退出，应用健壮性值得考验
- 大量计算占用CPU导致无法继续调用异步IO
Node采用 child_process子进程方式解决无法利用多核CPU方面的问题。通过Master-worker管理方式，也可以很好的管理各个工作进程。达到更高的健壮性。
4. Node 应用场景
- IO密集型。IO密集的优势主要在于Node 利用事件循环的处理能力，而不是启动每个线程为每一个请求进行服务，资源占用极少。
- 分布式应用

### 异步IO
1. nodejs vs nginx 
// https://gist.github.com/yhben/5201497
* 与Node的事件驱动，异步IO设计理念比较相近的是Nginx.Nginx采用纯C编写，性能表现优异。它们区别在于:Nginx具备面向客户端管理链接的强大能力，但是它的背后依然受限于各种同步方式的编程语言。但是Node是全方位的，既可以作为服务器去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。
* nginx和apache做的事情:网络层和HTTP协议层的解析和处理。
* 通常情况，我们不会在一个IP上只部署一个网站。在使用nodejs时，可使用connect提供的 vhots支持Virtual Host,但是也限制了服务只能使用nodejs 。而不能使用其他服务(php)。可以使用ngin的反向代理来解决。

2. 为什么要异步IO
web应用已经不再是单台服务器就能胜任的时代了，在跨网络的结构下，并发是现代编程中的 标准配置了。
- 用户体验
IO是昂贵的，分布式的IO更是昂贵的。只有后端能够快速的响应资源，才能让前端的体验变好。
- 资源分配
假设业务场景中有一组互不相关的任务需要完成，现在主流的方法如下:
* 单线程串行依次执行
* 多线程并行完成
如果创建多线程的开销小于并行执行，那么多线程的方式是首选，多线程的代价在于创建线程和执行期线程上下文切换和开销比较大。另外，在复杂的业务中，多线程编程经常面临锁，状态同步等问题，这是多线程被诟病的主要原因。但是多线程在多核CPU上能够有效的提升CPU的利用率，这个优势毋庸置疑。
操作系统会将CPU的时间分配给其余进程，以公平而有效的利用资源，基于这点，有的服务器为了提升响应能力，会通过启动多个工作进程来为更过的用户服务。但是对于这一组任务而言，它无法分发任务到多个进程上，所以依然无法高效利用资源，结束所有任务所需的时间将较长。这种模式类似三倍服务器，达到占用更多资源提升服务速度，但是并没有真正解决问题。
单线程同步模型是的阻塞IO导致硬件资源得到不到更优使用。多线程编程模型因为编程中的死锁，状态同步等问题让开发人员头疼。
Node在两者之间给出方案，利用单线程，原理多线程死锁，状态同步问题，利用异步IO，让单线程远离阻塞，更好利用CPU。

3. 异步IO和非阻塞IO
3.1 实际效果而言，异步和非阻塞都达到了我们并行IO的目的。
- 操作系统内核对于IO只有两种方式：阻塞和非阻塞。在调用阻塞IO时，应用程序需要等待IO完成才返回结果。
* 阻塞IO的一个特点是调用完成之后一定要等到操作系统内核层面完成所有操作后，调用才结束。阻塞IO造成CPU等待IO，浪费等待时间，CPU的处理能力不能得到充分的利用，为了提高性能，内核提供了非阻塞IO，非阻塞IO和阻塞UI区别在于调用之后立即返回。
* 非阻塞IO返回之后，CPU的时间片可以用来处理其他事务，此时性能提升是明显的。
但是非阻塞UI也有些问题，由于完整IO并没有完成，立即返回的并不是业务期望的数据，而仅仅是调用的状态。为了获取完成的数据，应用程序需要重复调用IO操作来确认是否完成。这种判断是否完成的技术叫“轮询”。
epoll: 是linux 下效率最高的IO事件通知机制，在进入轮询时候如果没有检查到IO事件，将会进行休眠，只到事件发生将它唤醒。它是真实利用事件通知，执行回调的方式。而不是真正的查询，所以不会浪费CPU，执行效率较高。

轮询的技术满足了非阻塞IO确保获取完整数据需求，但是对于应用程序而言，它任然只能算是一种同步，因为应用程序任然等待IO完全返回，依旧花费很多时间在等待。等待期间，CPU要不用于遍历文件描述符状态，用不用于休眠等待事件发生。结论是它不够好。


3.2 理想的非阻塞异步IO
完美的异步UI应该是应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，乐园直接处理下一个任务，只要在IO完成之后通过信号或者回调将数据传递给应用程序即可。
幸运的是Linux下存在这样方式: 它原生提供一种异步IO方式(AIO)就是通过信号好回调传递数据的。
但是这种方式只有Linux有，而且存在缺陷-AIO 仅支持内核IO中O_DIRCT方式读取，导致无法利用系统缓存。

3.3 现实的异步IO
前面我们将场景限了在单线程的情况西安，多线程的方式没有考虑到。通过让部分线程进行阻塞IO或者非阻塞UI加轮询技术来完成数据获取。让一个线程进行计算处理，通过线程之间通信将IO得到的数据进行传递，这就轻松实现了异步IO(模拟的)。
window下IOCP，在某种程度提供了理想的异步IO：调用异步方法，等待IO完成之后通知，执行回调，用户无需考虑轮询。内部任然是线程池原理，只是这些线程池由系统内核接管。

3.4 Node的异步IO
- 事件循环
进程启动时候，Node会创建一个类似while(true)的事件，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件等待处理，如果有就取出事件以及相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入循环，如果不再有事件处理就退出。
- 观察者
在每个Tick过程中，如何判断是否有事件需要处理呢。(观察者)
每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否要处理的事件。
-  请求对象

3.5 事件驱动和高性能的服务器
异步IO不仅仅应用在文件操作上，对于网络套接字处理，Node也应用了异步IO。
几种经典服务器模型:
* 同步式。对于同步式服务，一次只能处理一个请求，并且其余请求都处于等待状态
* 每进程/每线程。为每个请求启动一个进程，这样可以处理多个请求，但是不具备扩展性，因为系统资源有限。
* 每线程/每请求 为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定的内存，当大并发请求到来时，内存会被耗光。导致服务器缓慢。
每线程/每请求的方式目前还被Apache使用，Node通过事件驱动的方式处理请求，无须为每个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销。同时操作系统在调度任务时因为线程较少，上下切换代价较低。使得服务器能够有条不紊的处理请求，即使在大量连接请鲁昂下，也不受线程上下文切换开销影响，是Node高性能一个重要原因。

### 异步编程
有异步IO必有异步编程
1. 函数式编程
* 高阶函数
* 偏函数
2. 异步编程的优势和难点
提升性能方式过去使用多线程解决。但是多线程引入在业务逻辑方面制造的麻烦不少。从操作系统调用到多线程的上下文切换开销，到实际编程里的锁，同步等问题。让开发人员头疼的时候也不少。Node利用js及其内部的异步库，将异步直接提升到业务层面，这是一种创新。
2.1 优势:
Node 最大优势在于事件驱动和非阻塞的IO模型，非阻塞IO使得CPU和IO并不互相依赖等待，让资源得到更好利用。对于网络应用而言，并行带来想象空间更大，延展而开的是分布式和云。并行使得各个单点之间能够更有效的组织起来，使得Node在云计算中收到青睐原因。
2.2 难点:
- 异常处理
- 函数嵌套过深
- 阻塞代码
sleep(1000)的效果实现
```
var start = new Date();
while(new Date() - start < 1000) {
  // TODO
}
```
但是这段代码是糟糕的，这段代码会持续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环调度。由于Node单线程的原因，CPU资源都会用于这段代码服务，导致其余任何请求都得不到响应。
- 多线程编程
- 异步转同步
3. 异步编程解决方案
* 事件发布/订阅模式
* Proimse
* 流程控制库

### 内存控制
1. v8的垃圾回收机制和内存限制
1.1 Node 与V8
1.2 V8的内存限制
在Node中通过js使用内存时会发现只能使用部分内存。(64G为1.4G,32位为0.7G)。这样的限制下，将会导致Node无法直接操作大内存的对象，比如无法将2G文件读入到内存中进行字符串处理分析。
造成这个问题的主要原因是在于Node基于V8进行构建，所以在Node中使用js对象基本上都是通过V8自己的方式来进行分配和管理的，V8这套内存管理机制在浏览器的应用场景使用起来绰绰有余。足以胜任前端页面需求，但是在Node中却限制了开发者使用大内存想法。
1.3 V8对象分配
在V8中，所有的js对象都是通过堆来进行分配。Node提供了V8内存使用量的查看方式。
```
process.memoryUsage()
{ rss: 23638016,
  heapTotal: 7331840, V8申请到的内存
  heapUsed: 4926024, 使用的内存
  external: 8694
}
```
当我们代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，知道堆的大小超过V8限制为止。

至于V8为什么要限制大小，表层原因V8最初为浏览器而设计，不大可能遇到大量内存的场景。对于网页来说:V8的限制值已经绰绰有余。深层原因就是V8垃圾回收机制的限制。

以1.5G的垃圾堆内存为例，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。这是垃圾回收中引起js线程暂停执行的时间，在这样的事件花销下， 应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接收，前端浏览器也无法接受。因此，当当时的考虑直接限制堆内存是一个好的选择。

1.4 V8的垃圾回收机制
- V8主要垃圾回收算法
V8 垃圾回收策略主要基于分代式回收机制。在自动垃圾回收的演变过程中，人们发现没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一， 不同的算法只能针对特定的情况具有最好的效果。为此，统计学在垃圾回收算法发展中产生了较大的作用，现在垃圾回收算法中按照对象的存活事件将内存的垃圾回收进行不同的分代，然后分别对不同的分代的内存施加以更高效的算法。
* V8的内存分代
V8 中主要将内存分为新生代和老生代两代。新生代中的对象为存活的时间较短的对象，老生代的对象为存活时间较长或者常驻内存的对象。64位和32位系统分别只能使用1.4G和0.7G的内存。
* Scavenge算法
在分代基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体是现在，主要采用Cheney算法。


从V8的自动垃圾回收机制设计看到，V8对内存使用进行限制的缘故。新生代设计为一个较小的内存空间是合理的，而老生代空间过大对于垃圾回收并无特别意义。V8对内存限制的设置对于Chrome浏览器这种每个选项卡页面使用一个V8实例而言，内存的使用是绰绰有余了，对于Node编写的服务器来说，内存限制也并不影响正常场景下的使用。但是对于V8垃圾回收特点和Js在单线程运行执行情况看，垃圾回收是影响性能的因素之一。想要高性能的执行效率，需要注意让垃圾回收尽量的少进行，尤其是全堆垃圾回收。
以web服务器会话实现为例，一般通过内存来存储，但在访问量大的时候会导致老生代中存活对象骤增，不仅造成清理/整理过程耗时，还会造成内存紧张，甚至溢出。
2. 高效的使用内存
在V8面前，开发中所要具备的责任就是如何让垃圾回收机制更加高效的工作
2.1 作用域
函数调用，with以及全局作用域都会形成scope
```
var foo = function() {
  var local = {};
}
```
函数每次调用时会创建对应的作用域，函数执行结束之后，作用域会被销毁。同时作用域中声明的局部变量分配在该作用域上，随作用销毁而销毁。只被局部变量引用的对象存活周期较短。在作用域释放后，局部变量local失效，其引用的对象会在下次垃圾回收时被释放。
最基本的内存回收过程
- 标识符查找
- 作用域链
- 变量的主动释放
如果变量是全局变量，由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存(老生代中)。如果需要释放常驻内存的对象，可以通过delete来删除引用关系。或者从新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清理和整理过程中，会被回收释放。
2.2 闭包
我们知道作用域链上的对象访问只能向上，这样外部无法向内部访问。
js中实现外部作用域访问内部作用域的方法叫闭包，得益于高阶函数的特性。函数可以作为参数或者返回值。
闭包是js的高级特性，利用它可以产生很多技巧的效果，但是，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始作用域不会得到释放，作用域中产生的内存占用也不会得到释放，除非不再有引用，才会逐步得到释放。

2.3 小结
正常的js执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8内存限制，要非常小心此变量是否有无限的增加，因为它会导致老生代中的对象增多。

3. 内存指标
一般而言，应用中存在一些全局的对象是正常的，但是在正常的使用中，变量会自动的释放回收。但是也会存在一些我们认为会回收但是却没有释放回收的对象，会导致内存占用无限增长，一旦达到V8 的内存限制，将会得到内存溢出错误，导致进程退出

3.1 查看内存使用情况
使用process.memoryUsage()可以Node进程内存的占用情况。
os.totalmem()和os.freemem()这两个方法用于查看操作系统的内存使用情况,分别是总内存和闲置内存。
3.2  堆外内存
堆中的内存用量总是小雨进程常驻内存用量，意味着Node中内存使用并非都是通过V8进行分配的，我们将那些不是通过V8分配的内存称为堆外内存。
Buffer对象不同于其他的对象，他是不经过V8 的内存分配机制的，所以也不会有堆内存的大小限制。
为何Buffer对象并非通过V8分配，这在于Node并不同于浏览器使用场景。在浏览器中，js直接处理字符串即可满足绝大多数的业务需求，而在Node中则需要处理网络流和文件IO流，操作字符串远远不能满足传输的性能需求。

3.3 小结
Node内存构成主要是通过V8分配的部分和Node自行分配的部分，受V8垃圾回收限制的主要是V8 的堆内存
4. 内存泄露
Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，哪怕是一个字节的内存泄露也会造成堆积，垃圾回收过程将会耗费更多的时间进行对象的扫描，应用的响应缓慢，直到进程内存溢出，应用崩溃。
在V8的垃圾回收机制下，通常的代码编写中，很少会出现内存泄露的情况。但是内存泄漏通常产生与无意间难以排查。尽管内存泄露情况不尽相同，但是实质只有一个，就是应当回收的对象出现意外而没有被收回，变成了常驻在老生代的对象。
通常，造成内存泄露的原因有以下:
* 缓存
* 队列消费不及时
* 作用域未释放
4.1 慎将内存当作缓存
缓存在应用作用中举足轻重，可以十分有效的节省资源。因为它的访问效率比IO的效率更高，一旦命中缓存，就可以节省一次IO的时间。
在在Node中，缓存并非是物美价廉，一旦一个对象被当作缓存使用，那意味着它会将常驻在老生代中，缓存中存储的键越多，长期存活的对象越多，导致垃圾回收在扫描和整理时，对这些对象做无用功。
另一个问题在于：js开发者通常喜欢使用对象的键值来缓存东西，这和严格意义上的缓存有着区别，严格意义的缓存有着完善的过期策略，但是普通的键值对并没有。
underscore 的memorize的缓存，作为键进行缓存，以内存空间换取CPU执行时间，这里潜藏的陷阱是每个被执行的结果都会按参数缓存在 memo对象上，不会被清除。这在前端网页这种短时应用场景不会存在大的场景，但是执行量大和参数多样性的情况下，会造成内存占用不释放的问题。
在Node中任何视图那内存当作缓存的行为应该被限制，当然这种限制并不是不允许的意思，而是要小心而为。
- 缓存限制策略
为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。
- 缓存的解决方案
直接将内存作为缓存的方案要十分慎重。除了限制缓存大小之外，还要考虑进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免的重复，对物理内存的使用也是一种浪费。
如何使用大量缓存，目前比价好的方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存国旗淘汰策略以及自有的内存管理，不影响node进程性能。它的好处多多，在Node中主要可以解决以下两个问题。
（1）将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更加高效
（2）进程之间可以共享缓存
目前有redis和meecached。
4.2 关注队列状态
在解决缓存带来的内存泄露问题后，另外一个不经意产生内存泄露的则是队列。队列在消费者-生产者模型中经常充当中间产物。这是一个非常容易忽略情况，因为大多数场景消费速度大于生产速度，内存泄露不易产生。但是一旦消费速度大于生产速度，将形成堆积。

例子：有的应用会收集，如果欠缺考虑，也许采用数据库来纪录日志。日志通常是海量的，数据库构建在文件系统之上，写入效率远低于文件的写入于是会形成数据库写入操作堆积，而js中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄露。
