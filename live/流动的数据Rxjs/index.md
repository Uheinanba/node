### 问题
1. 有一些场景：
* 微博列表页面
* 各类协同工具的任务看板,如：teambition
2. 这类场景有些共同的特点：
* 若干个小方块构成
* 每个小方块需要以一个业务实体为主体(一条微博，一个任务)，聚合一些其他的关联信息(参与者，标签等)。
这样的一个界面，我们考虑它的完全展示，可能会有两种方案
* 服务端渲染，查询所有数据，生产HTML后发送给浏览器
* 前端渲染，查询所有数据，发送给浏览器生成HTML展示
微博使用的是前一种，引入了bigpipe生成界面，TB使用的是后一种，主要差别还是由于产品形态。

3. 业务的挑
在前端渲染的情况下，这么一种界面形态，所带来的挑战有哪些呢？
* 信息量大，导致查询比较复杂，其中有部分的数据是可复用的，比如：这么大片的面板，可能有几百条任务，但是其中人员可能就有20个，所有参与者都是在这20个人里面
* 如果要做一些实事的交互, 会比较麻烦，比如：某个用户修改了头像，某个标签定义修改了文字，都会需要立即更新当前界面所有的引用部分。

所以这就要求我们的数据查询是离散化的，任务信息和额外的关联信息分开查询，然后前端进行组装。这样一是可以减少传输的数据量，二是可以分析出数据之间的关心，更新的时候容易跟踪。

除此之外，TB的操作会在全业务维度使用WebSocket来做更新推送。当前任务看板中，有某个东西发生变化了（其他人创建任务，修改了字段），都会由服务端推送信息，来促使前端更新界面。
离散的数据会让我们需要使用缓存，比如，界面建立起来之后，如果有人在其他端创建了任务，那么本地的看板只需要收到这条任务信息并创建视图，并不需要查询人员，标签等关联信息，因为之前已经获取过。

某个视图组件的展示，如果需要ABC三个实体，其中，如果哪个实体存在缓存，就不去服务端拉去，只拉取无缓存实体。

有以下挑战：
- 查询同一种数据，可能是同步（缓存中读取），也可能是异步（AJAX获取），业务代码编写需要考虑这两种情况。
WebSocket推送则用来保证我们前端缓存的正确性，但是我们需要注意，WS的编程方式和AJAX不一样，WS是一种订阅，和主流很难整合起来，而AJAX可以组织得包含在主流程中

- 第二个挑战：
例如： 对同一种更新的不同发起方（自己修改一个东西，别人修改这个东西），这两种的后续其实一样，但是代码并不相同，需要写两份业务代码

获取数据和数据的更新通知，写法是不同的，会加大业务编码复杂度
我们的数据这么离散，从视图角度看，每块视图需要的数据都可能经过比较长而复杂的组合，才能满足展示需要。

- 第三个挑战
每个渲染数据，都是通过若干个查询的过程（组合同步异步）组合而成，如何清晰的定义这种组合关系？

- 第四个挑战
一组数据经过多种规则之后，又需要插入新的数据（主动新增一条，WS推送一条），这些新增数据都不能直接加进来，也必须走一遍这些规则，再合并到结果中

对于已有数据和未来数据，如何简化它们应用同样规则的代码复杂度


### 同步和异步
在前端我们经常会遇到同步和异步代码的统一，假设我们要实现某个方法：当有某个值的时候，就返回这个值，否则去服务端获取这个值。
通常使用Promise
```
function getDataP() {
  if (a) {
    return Promise.resolve(a)
  } else {
    return AJAX.get('a')
  }
}
```
不确定同步还是异步，就取异步，因为它可以兼容同步。rxjs中Observable也可以做到
```
function getDataO() {
  if (a) {
    return Observable.of(a)
  } else {
    return Observable.fromPromise(AJAX.get('a'))
  }
}
```
这段代码看起来还不如Promise，因为它还要转换。优势在哪里？
```
getDataP().then(data => {
  // Promise 只有一个返回值，响应一次
  console.log(data)
})

getDataO().subscribe(data => {
  // Observable 可以有多个返回值，响应多次
  console.log(data)
})
```

### 获取和订阅
通常我们在前端会使用观察者或者订阅发布模式来实现自定义事件这样的东西，实际上就是一种订阅。
从视图角度看，它面临的是：得到了一个新的任务数据，并且要展示它。
这个数据如何获取的：主动查询，还是别人推送过来的，都不重要，并不是它的职责，它只管显示。
所以，我们要给它封装两个东西
* 主动查询的数据
* 被动推送的数据
然后，就变成类似这样的东西
```
service.on('task', data => {
  // render
})
```
这样视图就可以用相同的方式应对两种不同的来源的数据，service内部可以把两者统一，在各自回调中触发自定义的事件
但是我们忽略了，视图除了响应这种事件之外，还需要主动触发以下初始化的查询请求
```
service.on('task', data => {
  // render
})

service.getData()   // 加了这么一句来主动触发请求
```

这样看起来还是挺别扭的，回到上一节里面我们的那个Observable示例：

```
getDataO().subscribe(data => {
  // render
})
```
这么一句就搞定了我们要求的所有事情，我们可以去这么理解这件事
* getDataO 是一个业务过程
* 业务过程的结果可以被订阅
这样我们就可以把获取和订阅这两件事合并到一起，视图层的关注点就简单很多了。


### 可组合的数据管道
依据上一节思路，我们可以把查询过程和WS响应过程抽象，融为一体。

一个视图需要的数据可能是这样的
* data1和data2通过某种组合，得到一个结果。
* 这个结果再去和data3组合，得到最终结果。

我们如何抽象这个过程呢？
我们可以把Observable视为一节数据流的管道吗，我们需要做的，就是依据他们的关系，把这些管道组合起来，这样从管道某个入口传入数据，在末端就可以得到最终结果。
Rxjs给我们提供了一堆操作符用于处理这些Observeble之间的关系，比如：我们可以这样
```
const A$ = Observable.interval(1000)
const B$ = Observable.of(3)
const C$ = Observable.from([5, 6, 7])

const D$ = C$.toArray()
  .map(arr => arr.reduce((a, b) => a + b), 0)
const E$ = Observable.combineLatest(A$, B$, D$)
   .map(arr => arr.reduce((a, b) => a + b), 0)
```
表达为：
```
A ------> |
B ------> | -> E
C -> D -> |
```
通过这种方式，我们可以描述出业务逻辑的组合关系，把每个小粒度的业务封装到数据管道中，然后对它们进行组装，拼装出整体逻辑来。

### 现在和未来
业务开发中，我们经常遇到这样场景
已经过滤排序的列表加入一条新的数据，要重新按照这条规则走一遍
简单类比：每个进教室的同学得到一颗糖
这句话表达两个含义
* 这句断言产生之前，对于已经在教师的每个人，都应该去给他们发一颗糖。
* 这个断言之后，再进去教室的每个人，都应得到一颗糖。

这里面，第一句表示现在，第二句表示未来。我们编写业务时候，往往把现在和为了分开考虑，而忽略他们存在深层次的一致性。

刚才的问题，得到的结论是：
进入本列表的数据都应当经过某种过滤规则和某种排序规则。
这才是一个合适的业务抽象，然后再编写代码就是
```
const final$ = source$.map(filterA).map(sorterA)
```
source代表来源，final代表结果，来源经过filterA和sorterA变换之后，得到结果。
然后我们再去考虑来源定义
```
const source$ = start$.merge(patch$)
```
来源等于初始数据与新增数据的合并。
然后，实现出filterA和sorterA,就完成整个这段业务逻辑的抽象定义。给start和patch分别定义，比如：start是查询，patch是推送，它是可运行的了。最后我们在final上添加一个订阅，整个过程完美的映射到界面上。
很多时候，我们编写的代码会考虑今后合适的抽象,但是这两个字代表的含义很多场景不相同。
一般场景下，业务单元的抽象难道相对较低，很容易理解，也容易获得关注，所以通常都能做的不错，比如最近几年，对于组件化之类的话题，都能够谈的起来，但对于业务逻辑抽象，大部分项目做的还是不不够，值得深思。


### 视图如何使用数据流
上面我们谈的是在业务逻辑角度如何使用Rxjs来组织获取和变更封装，最终，这些东西是需要反映到视图上去，这里面有些什么有意思的东西呢。
主流的MV*框架都是介于一个共同的理念：MDV，这个理念下，一切对于视图的变更，首先都应当是模型的变更，然后通过模型和视图的映射关系，自动的同步。
这个过程中，可能需要一些方式定义这种关系，比如：Ng和Vue中的模版，react和JSX等等。
这些体系中，如果要是有Rxjs 的Observarble,都非常简单。
```
data$.subscribe(data => {
  // 这里根据所使用的视图库，用不同的方式响应数据
  // 如果是 React 或者 Vue，手动把这个往 state 或者 data 设置
  // 如果是 Angular 2，可以不用这步，直接把 Observable 用 async pipe 绑定到视图
  // 如果是 CycleJS ……
})
```

我们从视图的角度，还可以对Rxjs得出什么思考呢？
- 实现异步的计算属性


### 小结
使用Rxjs我们可达到以下目的
* 同步和异步的统一
* 获取和订阅的统一
* 现在和未来的统一
* 可组合的数据变更的过程

// https://www.zhihu.com/question/51944726?from=profile_question_card